---
description: 
globs: justfile,*.bash
alwaysApply: false
---
# Bash Coding Standards Guide

## General Principles
- Use Bash 5.x features freely - we do NOT require POSIX compatibility
- Prioritize builtin commands over external processes for performance
- Write robust, error-resistant code by default
- Maintain readability while being mindful of performance

## Script Structure
- Always start with a proper shebang: `#!/usr/bin/env bash`
- Set appropriate options near the top of scripts:
  ```bash
  set -euo pipefail  # Exit on error, undefined vars, and pipeline failures
  ```
- Include a brief description and usage example in a comment
- Structure larger scripts with functions for modularity
- Keep related functionality grouped together

## Performance Best Practices
- Use builtins over external commands whenever possible:
  - Use `[[ ]]` instead of `[ ]` or `test`
  - Use parameter expansion (`${var#prefix}`) instead of `sed`/`cut`/`awk`
  - Use `mapfile`/`readarray` instead of `while read` loops
  - Use `printf` instead of `echo` for formatted output
  - Use Bash's regex matching (`[[ $string =~ $regex ]]`) instead of `grep`
- Avoid unnecessary subshells and command substitutions
- Minimize process spawning in loops
- Use process substitution (`<(command)`) instead of pipes when appropriate
- Cache expensive operations rather than recomputing
- Use Bash arrays properly rather than string splitting

## Syntax Guidelines
- Use double quotes around variables to prevent word splitting: `"$variable"`
- Use `[[ ]]` for conditions, not `[ ]`
- Use `((` `))` for arithmetic operations, not `expr`
- Use parameter expansion for string operations:
  ```bash
  # Good
  filename="${path##*/}"
  extension="${filename##*.}"
  
  # Bad
  filename=$(basename "$path")
  extension=$(echo "$filename" | cut -d. -f2)
  ```
- Use `mapfile` or `readarray` for reading files into arrays:
  ```bash
  # Good
  mapfile -t lines < file.txt
  
  # Bad
  lines=()
  while IFS= read -r line; do
    lines+=("$line")
  done < file.txt
  ```
- Prefer `printf` over `echo` for precision and portability

## Error Handling
- Check for errors and provide helpful error messages
- Use descriptive return codes
- Consider traps for cleanup:
  ```bash
  trap 'rm -f "$tempfile"' EXIT
  ```
- Validate user input and command-line arguments

## Variable Naming
- Use lowercase for local variables: `local my_var="value"`
- Use uppercase for environment variables and constants: `readonly MAX_ATTEMPTS=5`
- Use descriptive names that reflect purpose
- Prefer `snake_case` for multi-word variable names

## Functions
- Define functions using the modern syntax:
  ```bash
  function_name() {
    # implementation
  }
  ```
- Keep functions focused on a single responsibility
- Document function parameters and return values in comments
- Use `local` for function-scoped variables

## Examples

### String Operations (efficient)
```bash
# Bad (spawns processes)
basename=$(basename "$path")
dirname=$(dirname "$path")

# Good (Bash builtins only)
basename="${path##*/}"
dirname="${path%/*}"
```

### Checking if a string contains a substring
```bash
# Bad (spawns process)
if echo "$string" | grep -q "$substring"; then

# Good (Bash builtin)
if [[ "$string" == *"$substring"* ]]; then
```

### Reading file contents
```bash
# Bad (spawns process)
content=$(cat file.txt)

# Good (Bash redirection)
content=$(<file.txt)
```

### Checking if a command exists
```bash
# Bad (external process)
if which command &>/dev/null; then

# Good (Bash builtin)
if command -v command &>/dev/null; then
```

### Array iteration
```bash
# Bad (ignores spaces, special chars)
for i in $items; do

# Good (preserves elements properly)
for i in "${items[@]}"; do
```

### String splitting
```bash
# Bad (vulnerable to word splitting)
IFS=',' read -ra parts <<< "$csv_line"

# Good (safer, more efficient)
mapfile -td, parts <<< "$csv_line"
```

This guide will help ensure that all bash scripts in the project are efficient, robust, and follow modern Bash best practices.